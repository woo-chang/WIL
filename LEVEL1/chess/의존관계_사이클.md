## 의존관계 사이클

다른 말들과 다르게 `Pawn`이라는 기물은 움직일 때 추가적인 제약조건이 있기에 별도 처리가 필요하다. 결국 보드에서 최종적으로 기물에 따라 다시 한번 움직일 수 있는지 확인이 필요한데, 각 기물에게 물어보는
방법을 고려해볼 수 없을까 하는 리뷰가 있었다.

보드를 기물에 넘겨 움직임 여부를 판별할 수 있지만 **보드 -> 기물 -> 보드**순으로 의존관계 사이클이 발생하게 된다. 한쪽으로 흐르는 단방향 의존관계가 아닌 양방향 의존관계를 가지게 되는 경우 결합도가
높아지게 되어 확장성이 낮아지고 유지보수가 어려워지는 문제가 발생하게 된다. 이를 설명해 드렸더니 리뷰어의 답변은 아래와 같았다.

> 저도 보드 -> 기물 -> 보드 사이클이 우려스럽긴 합니다. 모든 구현은 트레이드 오프이기 때문에 역할과 책임을 한 곳에서 관리하기 vs 의존성 사이클로부터 방어하기 사이에서 장단점을 확인해보고 좋은 방법을
> 선택하면 된다고 생각합니다. 저라면 기물 스스로 책임을 다하는 방식으로 진행할 것 같습니다. 추가로 생각나는 아이디어는 보드의 스냅샷을 카피한 후 넘겨주는 것도 방법이 될 수 있을 것 같아요.

보드를 그대로 넘기게 되면 보드가 가지고 있는 메서드를 사용할 여지가 있기에 의존관계 사이클의 위험이 존재하지만, 기물이 필요한 것은 보드 자체가 아닌 보드판에 대한 정보이기에 정보만을 카피해서 넘겨주는 것은 좋은
방법이 될 수 있었다. 모든 선택은 트레이드 오프라는 것을 다시 한번 느낄 수 있었고 선택하더라도 단점을 보완하기 위한 방법을 찾아낼 수 있다는 것도 직접 확인할 수 있었다.
